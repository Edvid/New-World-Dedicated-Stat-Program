import { loadGameFromSafeFile } from "../gameloading/loadChangesFromFile.js";
import { Header } from "../components/header.js";
import {
  RGBAToHex,
  ImageIndexToIntColor,
  ImageIndexToRGBA,
  IntColorToRGBA,
  RGBAtoRGB,
} from "../utility/color_manipulation.js";
import { prepareData } from "../utility/images/prepare_data.js";
import { reportProgress } from "../utility/report_progress.js";
import { trimIndents } from "../utility/string_manipulation.js";
import {
  getGameStats,
  mappedResources,
  mappedResourcesMultipliers,
} from "../stats/gameStats.js";
import { WIDTH, HEIGHT } from "../utility/images/consts.js";
import { populationMapToHumanReadable } from "../utility/images/population_map_to_human_readable.js";
import {
  fillInColorProperties,
  colorProperty,
} from "../utility/mapcalc/color_properties.js";
import {
  ReportingElements,
  findDistribution,
  isValueModeNormal,
} from "../utility/mapcalc/find_distribution.js";
import { generateCCFForSocialBehaviourGroups } from "../utility/mapcalc/generate_ccf_for_social_behaviour_groups.js";
import { error } from "../utility/custom_errors.js";

let baseData: ImageDataArray;
let nationData: ImageDataArray;
let climateData: ImageDataArray;
let coastData: ImageDataArray;
let developmentData: ImageDataArray;
let cultureData: ImageDataArray;
let religionData: ImageDataArray;
let tradeZoneData: ImageDataArray;
let fertilityData: ImageDataArray;
let popData: ImageDataArray;
let newPopData: ImageDataArray;
let newFuturePopData: ImageDataArray;

let populationXDevelopmentData: ImageDataArray;

let nationColorProperties: colorProperty[];
let climateColorProperties: colorProperty[];
let cultureColorProperties: colorProperty[];
let religionColorProperties: colorProperty[];
let tradeZoneColorProperties: colorProperty[];
let fertilityColorProperties: colorProperty[];
const coastColorProperties: colorProperty[] = [
  { color: "00ffff", name: "coast" },
];

document.body.prepend(Header());

export const progressText: HTMLElement =
  document.querySelector(".progressText");
progressText.innerText = "Loading...";
const promptMissingInfoContainer: HTMLElement = document.querySelector(
  ".promptMissingInfoContainer",
);
const promptedMissingInfoCanvas: HTMLCanvasElement = document.querySelector(
  ".promptMissingInfoContainer canvas",
);
promptedMissingInfoCanvas.width = WIDTH;
promptedMissingInfoCanvas.height = HEIGHT;
const promptLabel: HTMLElement = document.querySelector(
  ".promptMissingInfoContainer label",
);
const promptField: HTMLInputElement = document.querySelector(
  ".promptMissingInfoContainer .promptField",
);

const submitButton: HTMLButtonElement = document.querySelector(
  ".promptMissingInfoContainer .promptButton",
);
const autoGeneratedCffTextField: HTMLInputElement = document.querySelector(
  ".autoGeneratedCffTextField",
);
const imageOutputContainer = document.querySelector(".OutputImagesContainer");

const copyToClipboardButton: HTMLButtonElement =
  document.querySelector("button#clipboard");

copyToClipboardButton.onclick = function () {
  // Select the text field
  autoGeneratedCffTextField.select();
  autoGeneratedCffTextField.setSelectionRange(0, 99999); // For mobile devices
  navigator.clipboard.writeText(autoGeneratedCffTextField.value);
};

await loadGameFromSafeFile();

await mapCalculations();

async function mapCalculations() {
  const gameStats = getGameStats();
  nationColorProperties = fillInColorProperties(gameStats.Nations);
  climateColorProperties = fillInColorProperties(gameStats.Climates);
  cultureColorProperties = fillInColorProperties(gameStats.Cultures);
  religionColorProperties = fillInColorProperties(gameStats.Religions);
  tradeZoneColorProperties = fillInColorProperties(gameStats.TradeZones);
  fertilityColorProperties = fillInColorProperties(gameStats.Fertility);

  baseData = await prepareData("Blank.png", progressText);

  nationData = await prepareData("Nations.png", progressText);
  climateData = await prepareData("Climates.png", progressText);
  coastData = await prepareData("CoastalLand.png", progressText);
  developmentData = await prepareData("Development.png", progressText);
  cultureData = await prepareData("Cultures.png", progressText);
  religionData = await prepareData("Religions.png", progressText);
  tradeZoneData = await prepareData("TradeZones.png", progressText);
  fertilityData = await prepareData("Fertility.png", progressText);
  popData = await prepareData("Code/Population.png", progressText);

  const reportingElements: ReportingElements = {
    progressElement: progressText,
    promptLabel: promptLabel,
    promptField: promptField,
    promptSubmitButton: submitButton,
    promptMissingInfoContainer: promptMissingInfoContainer,
    promptedMissingInfoCanvas: promptedMissingInfoCanvas,
    addToTextOutput: addToTextOutput,
    mapToDrawOn: baseData,
  };

  progressText.innerText = "reversing development map";
  await new Promise((resolve) => setTimeout(resolve));

  developmentData = await mapDataIterator(reverseRBGsOfDevelopment);

  progressText.innerText = "loading population X development";
  await new Promise((resolve) => setTimeout(resolve));

  populationXDevelopmentData = await mapDataIterator(
    populationXDevelopmentMerger,
  );

  progressText.innerText =
    "adjusting culture map data for population and development";
  await new Promise((resolve) => setTimeout(resolve));

  const climateDistribution = await findDistribution(
    nationData,
    climateData,
    "nation",
    "climate",
    nationColorProperties,
    climateColorProperties,
    reportingElements,
    {
      valueMode: "normal",
      unassignedPixelAssumption: "Moderate",
    },
  );

  const coastPopCount = await findDistribution(
    nationData,
    popData,
    "nation",
    "coastal population",
    nationColorProperties,
    coastColorProperties,
    reportingElements,
    {
      canIgnoreTransparentInner: true,
      valueMode: "RGBAsNum",
      unassignedPixelAssumption: 0,
      Adjuster: coastData,
      AdjusterMapping: (e) => {
        return e == 0x00ff00;
      },
    },
  );

  const developmentScore = await findDistribution(
    nationData,
    developmentData,
    "nation",
    "development",
    nationColorProperties,
    [],
    reportingElements,
    {
      canIgnoreTransparentInner: true,
      unassignedPixelAssumption: 0,
      valueMode: "greyScale",
    },
  );

  const socialBehaviourGroupDistributionValueMode = "normal"

  const cultureDistribution = await findDistribution(
    nationData,
    cultureData,
    "nation",
    "popdev-adjusted-culture",
    nationColorProperties,
    cultureColorProperties,
    reportingElements,
    {
      valueMode: socialBehaviourGroupDistributionValueMode,
      unassignedPixelAssumption: "Foreign",
      Adjuster: popData,
    },
  );

  const religionDistribution = await findDistribution(
    nationData,
    religionData,
    "nation",
    "popdev-adjusted-religion",
    nationColorProperties,
    religionColorProperties,
    reportingElements,
    {
      valueMode: socialBehaviourGroupDistributionValueMode,
      unassignedPixelAssumption: "Pagan",
      Adjuster: popData,
    },
  );

  const tradeZoneScoreValueMode = "RGBAsNum";

  const tradeZoneScore = await findDistribution(
    tradeZoneData,
    populationXDevelopmentData,
    "trade zone",
    "wealth",
    tradeZoneColorProperties,
    [],
    reportingElements,
    {
      canIgnoreTransparentInner: true,
      valueMode: tradeZoneScoreValueMode,
      unassignedPixelAssumption: 0,
    },
  );

  addToTextOutput(
    `<... > Nations
     !suppress 99999

     `,
  );

  if (!isValueModeNormal(socialBehaviourGroupDistributionValueMode, cultureDistribution)) {
    error(`Wrong value mode was provided to the distribution finder for cultureDistribution. Report this to admins`);
    return;
  }
  if (!isValueModeNormal(socialBehaviourGroupDistributionValueMode, religionDistribution)) {
    error(`Wrong value mode was provided to the distribution finder for religionDistribution. Report this to admins`);
    return;
  }
  generateCCFForSocialBehaviourGroups("CultureGroups", cultureDistribution)
  generateCCFForSocialBehaviourGroups("ReligionGroups", religionDistribution)

  //add climate distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(climateDistribution).forEach((nationKey) => {
    Object.keys(climateDistribution[nationKey]).forEach((climateKey) => {
      addToTextOutput(
        `= ${climateDistribution[nationKey][climateKey]} ${nationKey}.${climateKey}\n`,
      );
    });
  });

  //add development distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(developmentScore).forEach((nationKey) => {
    addToTextOutput(
      `= ${developmentScore[nationKey]} ${nationKey}.DevelopmentPixelCount\n`,
    );
  });

  //add coast distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(coastPopCount).forEach((nationKey) => {
    addToTextOutput(
      `= ${coastPopCount[nationKey]} ${nationKey}.coastalPopulation\n`,
    );
  });

  addToTextOutput(
    `<... > Nations
     `,
  );

  /* #region  Everthing resources */

  for (let r = 0; r < mappedResources.length; r++) {
    const resourceName = mappedResources[r];

    let resourceData = null;

    resourceData = await prepareData(`Code/Resources/${resourceName}.png`);

    progressText.innerText = "";

    const resourceBlobSizes = (
      await findDistribution(
        () => {
          return 255;
        },
        resourceData,
        "world",
        resourceName,
        [{ color: "ffffff", name: "world" }],
        (name) => {
          return { color: name, name: "Col" + name };
        },
        reportingElements,
        {
          skipsTransparentInner: true,
          unnamedGroup: true,
          valueMode: "normal",
          unassignedPixelAssumption: "!!!", // should no be possible to use, as colorToInnerNameMapping never returns undefined no matter the provided name
        },
      )
    )["world"];

    //find nations' max resources

    const resourceOverlap = await findDistribution(
      nationData,
      resourceData,
      "nation",
      resourceName,
      nationColorProperties,
      (e) => {
        return { color: e, name: "Col" + e };
      },
      reportingElements,
      {
        skipsTransparentInner: true,
        unnamedGroup: true,
        valueMode: "normal",
        unassignedPixelAssumption: "!!!", // should no be possible to use, as colorToInnerNameMapping never returns undefined no matter the provided name
      },
    );

    //use resourceBlobSizes to divide all.

    Object.keys(resourceOverlap).forEach((nationKey) => {
      let count = 0.0;

      //counting up all pixels overlapping per blob, divided by the blob's size
      Object.keys(resourceOverlap[nationKey]).forEach((ColorKey) => {
        count +=
          resourceOverlap[nationKey][ColorKey] / resourceBlobSizes[ColorKey];
      });

      //resource blob number multiplication
      count *= mappedResourcesMultipliers[r];

      addToTextOutput(
        `= ${(Math.round(count * 20) / 20).toFixed(2)} ${nationKey}.Max${resourceName}
         `,
      );
    });
  }

  /* #endregion */

  //add trade zone wealths to autogeneratedccf

  addToTextOutput(
    `<... > TradeZones
     `,
  );

  if (isValueModeNormal(tradeZoneScoreValueMode, tradeZoneScore)) {
    error(`Wrong value mode was provided to the distribution finder for tradeZoneScore. Report this to admins`);
    return;
  }

  //climate * totaldevscore (255 per pixel)
  Object.entries<number>(tradeZoneScore).forEach(([zoneName, score]) => {
    const idealTradeZoneScore = score / 10000;
    addToTextOutput(
      `= ${(Math.round(idealTradeZoneScore * 20) / 20).toFixed(2)} ${zoneName}.Score\n`,
    );
  });

  await prepareNewMaps();

  const URLParamSetup = new URLSearchParams(window.location.search).get(
    "setup",
  );
  const isSetup = URLParamSetup != null;

  console.log(isSetup);

  const nationPopDistribution = await findDistribution(
    nationData,
    isSetup ? popData : newPopData,
    "nation",
    "population",
    nationColorProperties,
    [],
    reportingElements,
    {
      valueMode: "RGBAsNum",
      unassignedPixelAssumption: 0,
    },
  );

  const nationPopXDevDistribution = await findDistribution(
    nationData,
    populationXDevelopmentData,
    "nation",
    "population",
    nationColorProperties,
    [],
    reportingElements,
    {
      valueMode: "RGBAsNum",
      unassignedPixelAssumption: 0,
    },
  );

  const nationFuturePopDistribution = await findDistribution(
    nationData,
    isSetup ? newPopData : newFuturePopData,
    "nation",
    "future population",
    nationColorProperties,
    [],
    reportingElements,
    {
      valueMode: "RGBAsNum",
      unassignedPixelAssumption: 0,
    },
  );

  const nationFertilityDistribution = await findDistribution(
    nationData,
    fertilityData,
    "nation",
    "fertility",
    nationColorProperties,
    fertilityColorProperties,
    reportingElements,
    {
      valueMode: "normal",
      unassignedPixelAssumption: "Infertile",
    },
  );

  //add population distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(nationPopDistribution).forEach((nationKey) => {
    addToTextOutput(
      `= ${nationPopDistribution[nationKey]} ${nationKey}.Population\n`,
    );
  });

  //add urban pop to autogeneratedccf
  Object.keys(nationPopXDevDistribution).forEach((nationKey) => {
    addToTextOutput(
      `= ${nationPopXDevDistribution[nationKey]} ${nationKey}.urbanPopulation\n`,
    );
  });

  //add future population distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(nationFuturePopDistribution).forEach((nationKey) => {
    addToTextOutput(
      `= ${nationFuturePopDistribution[nationKey]} ${nationKey}.Future Population\n`,
    );
  });

  //add fertility distributions to autogeneratedccf

  addToTextOutput(
    `<... > Nations
     `,
  );

  Object.keys(nationFertilityDistribution).forEach((nationKey) => {
    let total = 0;
    Object.keys(nationFertilityDistribution[nationKey]).forEach(
      (FertilityKey) => {
        const fertilityColor = gameStats.Fertility[FertilityKey].Color;
        let fertilityMultiplier = 0;

        fertilityColorProperties.forEach((colorNamePair) => {
          if (colorNamePair.color == fertilityColor) {
            fertilityMultiplier = gameStats.Fertility[FertilityKey].Score;
            return;
          }
        });

        total +=
          nationFertilityDistribution[nationKey][FertilityKey] *
          fertilityMultiplier;
      },
    );
    addToTextOutput(`= ${total} ${nationKey}.Fertility\n`);
  });

  addToTextOutput(
    `!suppress 0
      <...
      `,
  );

  //add to autogeneratedccf

  copyToClipboardButton.disabled = false;

  progressText.innerText = `Done`;
}

function advancePopulationMap(imgArray, pixelIndex, options) {
  const gameStats = getGameStats();
  const pixel = ImageIndexToRGBA(imgArray, pixelIndex);
  if (pixel[3] < 128) return pixel; //if transparent, don't modify the pixel at all

  let pixelPop = pixel[0];
  pixelPop *= 255;
  pixelPop += pixel[1];
  pixelPop *= 255;
  pixelPop += pixel[2];

  const propertyData = options.propertyData;
  const colorProperties = options.colorProperties;
  const developmentData = options.development;

  function fetchPropertyObject(dataName) {
    const foundRGBA = ImageIndexToRGBA(propertyData[dataName], pixelIndex);
    const color = RGBAToHex(RGBAtoRGB(foundRGBA));
    let pair;
    colorProperties[dataName].forEach((colorNamePair) => {
      if (colorNamePair.color == color) {
        pair = colorNamePair;
        return;
      }
    });

    return pair;
  }

  function fetchName(dataName) {
    const pair = fetchPropertyObject(dataName);
    return typeof pair !== "undefined" ? pair.name : null;
  }

  function fetchBinary(dataName, isName) {
    const propertyPair = fetchPropertyObject(dataName);
    const nullableName = propertyPair ? propertyPair.name : `not-${isName}`;
    return nullableName == isName;
  }

  const nationName = fetchName("nation");
  const n = gameStats.Nations[nationName];
  const hasVaccine = typeof n !== "undefined" ? n.Technologies.Vaccines : false;
  const pseudoPopulationGrowth =
    typeof n !== "undefined" ? n.PseudoPopulationGrowth : 0.1;
  const effectiveHealth = typeof n !== "undefined" ? n.EffectiveHealth : 0;

  const climateName = fetchName("climate");
  const climateScore =
    gameStats.Climates[climateName].ClimateScore +
    (hasVaccine
      ? climateName == "SubTropical" ||
        climateName == "Tropical" ||
        climateName == "Savanna"
        ? 0.1
        : 0
      : 0);

  const isCoastalPixel = fetchBinary("coastal", "coast");

  let developmentScore = ImageIndexToRGBA(developmentData, pixelIndex)[0]; //reading red channel as shorthand for greyscale
  developmentScore = developmentScore / 255;

  const fertilityName = fetchName("fertility");
  const fertilityScore = gameStats.Fertility[fertilityName].Score;

  const pixelsDisease =
    pixelPop / (20 * climateScore) / 25 -
    effectiveHealth -
    (isCoastalPixel ? 0.1 : 0) +
    (0.5 - fertilityScore) / 2.5 -
    developmentScore * 5;
  const pixelsPopGrowth =
    pseudoPopulationGrowth < 0
      ? pseudoPopulationGrowth
      : pseudoPopulationGrowth * (1 - pixelsDisease);

  const newPixelPop = pixelPop * (1 + pixelsPopGrowth);
  return IntColorToRGBA(newPixelPop);
}

async function prepareNewMaps() {
  const datasets = {
    nation: nationData,
    climate: climateData,
    coastal: coastData,
    fertility: fertilityData,
  };
  const colorprops = {
    nation: nationColorProperties,
    climate: climateColorProperties,
    coastal: coastColorProperties,
    fertility: fertilityColorProperties,
  };

  newPopData = await advanceMap(popData, advancePopulationMap, {
    propertyData: datasets,
    colorProperties: colorprops,
    development: developmentData,
  });
  await addToImageOutput(newPopData, "Population map");

  newFuturePopData = await advanceMap(newPopData, advancePopulationMap, {
    propertyData: datasets,
    colorProperties: colorprops,
    development: developmentData,
  });
  await addToImageOutput(newFuturePopData, "Future Population map");

  const playerReadablePopData = await advanceMap(
    popData,
    populationMapToHumanReadable,
    {},
  );
  await addToImageOutput(
    playerReadablePopData,
    "Player-readable population map",
  );
}

async function mapDataIterator(delegate) {
  const ret = new Uint8ClampedArray(WIDTH * HEIGHT * 4);

  let then = Date.now();
  for (let i = 0; i < ret.length / 4; i++) {
    const res = delegate(i * 4);
    ret[i * 4] = res[0];
    ret[i * 4 + 1] = res[1];
    ret[i * 4 + 2] = res[2];
    ret[i * 4 + 3] = res[3];
    if (i % WIDTH == 0) {
      const now = Date.now();
      if (now - then > 100) {
        await reportProgress(i, progressText);
        await new Promise((resolve) => setTimeout(resolve));
        then = now;
      }
    }
  }

  return ret;
}

async function advanceMap(imgArray, formula, options) {
  const newImgArray = new Uint8ClampedArray(imgArray.length);

  let then = Date.now();
  for (let i = 0; i < newImgArray.length; i += 4) {
    const now = Date.now();
    if (now - then > 2000) {
      await new Promise((resolve) => setTimeout(resolve));
      reportProgress(i / 4, progressText);
      then = now;
    }

    const newPixel = formula(imgArray, i, options);

    newImgArray[i] = newPixel[0];
    newImgArray[i + 1] = newPixel[1];
    newImgArray[i + 2] = newPixel[2];
    newImgArray[i + 3] = newPixel[3];
  }

  return newImgArray;
}

function addToTextOutput(text: string) {
  autoGeneratedCffTextField.value += trimIndents(text);
}

async function addToImageOutput(imgArray, imgName) {
  const size = 2;

  const canvasContainer = document.createElement("div");
  const canvasLabel = document.createElement("label");
  canvasLabel.innerText = imgName;
  const canvasLink = document.createElement("canvas");
  canvasLink.width = WIDTH;
  canvasLink.height = HEIGHT;
  canvasLink.style.width = size * 2 + "cm";
  canvasLink.style.height = size + "cm";

  canvasLink
    .getContext("2d")
    .putImageData(new ImageData(imgArray, WIDTH), 0, 0);

  canvasContainer.appendChild(canvasLabel);
  canvasContainer.appendChild(document.createElement("br"));
  canvasContainer.appendChild(canvasLink);
  imageOutputContainer.appendChild(canvasContainer);
}

function reverseRBGsOfDevelopment(mapIndex) {
  return [
    255 - developmentData[mapIndex],
    255 - developmentData[mapIndex + 1],
    255 - developmentData[mapIndex + 2],
    developmentData[mapIndex + 3],
  ];
}

function populationXDevelopmentMerger(mapIndex) {
  const pixelPop = ImageIndexToIntColor(popData, mapIndex);
  const pixelDev = developmentData[mapIndex] / 255;
  const ret = pixelPop * pixelDev;

  return IntColorToRGBA(ret);
}
