import { loadGameFromSafeFile } from "../gameloading/loadChangesFromFile.js";
import { Header } from "../components/header.js";
import { RGBAToHex, ImageIndexToIntColor, ImageIndexToRGBA, IntColorToRGBA } from "../utility/color_manipulation.js";
import { prepareData } from "../utility/images/prepare_data.js";
import { reportProgress } from "../utility/report_progress.js";
import { trimIndents } from "../utility/string_manipulation.js";
import { getGameStats, mappedResources, mappedResourcesMultipliers } from "../stats/gameStats.js";
import { WIDTH, HEIGHT } from "../utility/images/consts.js";
import { populationMapToHumanReadable } from "../utility/images/population_map_to_human_readable.js";
import { fillInColorProperties } from "../utility/mapcalc/color_properties.js";
let promptFieldReturnedText = "";
let baseData;
let nationData;
let climateData;
let coastData;
let developmentData;
let cultureData;
let religionData;
let tradeZoneData;
let fertilityData;
let popData;
let newPopData;
let newFuturePopData;
let populationXDevelopmentData;
let nationColorProperties;
let climateColorProperties;
let cultureColorProperties;
let religionColorProperties;
let tradeZoneColorProperties;
let fertilityColorProperties;
const coastColorProperties = [{ color: "00ffff", name: "coast" }];
document.body.prepend(Header());
const progressText = document.querySelector(".progressText");
progressText.innerText = "Loading...";
const promptMissingInfoContainer = document.querySelector(".promptMissingInfoContainer");
const promptedMissingInfoCanvas = document.querySelector(".promptMissingInfoContainer canvas");
promptedMissingInfoCanvas.width = WIDTH;
promptedMissingInfoCanvas.height = HEIGHT;
const promptLabel = document.querySelector(".promptMissingInfoContainer label");
const promptField = document.querySelector(".promptMissingInfoContainer .promptField");
const submitButton = document.querySelector(".promptMissingInfoContainer .promptButton");
submitButton.addEventListener("click", function () {
    promptFieldReturnedText = promptField.value;
    promptMissingInfoContainer.hidden = true;
});
const autoGeneratedCffTextField = document.querySelector(".autoGeneratedCffTextField");
const imageOutputContainer = document.querySelector(".OutputImagesContainer");
const copyToClipboardButton = document.querySelector("button#clipboard");
copyToClipboardButton.onclick = function () {
    // Select the text field
    autoGeneratedCffTextField.select();
    autoGeneratedCffTextField.setSelectionRange(0, 99999); // For mobile devices
    navigator.clipboard.writeText(autoGeneratedCffTextField.value);
};
await loadGameFromSafeFile();
await mapCalculations();
async function mapCalculations() {
    const gameStats = getGameStats();
    nationColorProperties = fillInColorProperties(gameStats.Nations);
    climateColorProperties = fillInColorProperties(gameStats.Climates);
    cultureColorProperties = fillInColorProperties(gameStats.Cultures);
    religionColorProperties = fillInColorProperties(gameStats.Religions);
    tradeZoneColorProperties = fillInColorProperties(gameStats.TradeZones);
    fertilityColorProperties = fillInColorProperties(gameStats.Fertility);
    baseData = await prepareData("Blank.png", progressText);
    nationData = await prepareData("Nations.png", progressText);
    climateData = await prepareData("Climates.png", progressText);
    coastData = await prepareData("CoastalLand.png", progressText);
    developmentData = await prepareData("Development.png", progressText);
    cultureData = await prepareData("Cultures.png", progressText);
    religionData = await prepareData("Religions.png", progressText);
    tradeZoneData = await prepareData("TradeZones.png", progressText);
    fertilityData = await prepareData("Fertility.png", progressText);
    popData = await prepareData("Code/Population.png", progressText);
    progressText.innerText = "reversing development map";
    await new Promise((resolve) => setTimeout(resolve));
    developmentData = await mapDataIterator(reverseRBGsOfDevelopment);
    progressText.innerText = "loading population X development";
    await new Promise((resolve) => setTimeout(resolve));
    populationXDevelopmentData = await mapDataIterator(populationXDevelopmentMerger);
    progressText.innerText = "loading population X (100% + development/2)";
    await new Promise((resolve) => setTimeout(resolve));
    progressText.innerText =
        "adjusting culture map data for population and development";
    await new Promise((resolve) => setTimeout(resolve));
    const climateDistribution = await findDistribution(nationData, climateData, "nation", "climate", nationColorProperties, climateColorProperties, {
        unassignedPixelAssumption: "Moderate",
    });
    const coastPopCount = await findDistribution(nationData, popData, "nation", "coastal population", nationColorProperties, coastColorProperties, {
        canIgnoreTransparentInner: true,
        valueMode: "RGBAsNum",
        unassignedPixelAssumption: 0,
        Adjuster: coastData,
        AdjusterMapping: (e) => {
            return e == 0x00ff00;
        },
    });
    const developmentScore = await findDistribution(nationData, developmentData, "nation", "development", nationColorProperties, 0, {
        canIgnoreTransparentInner: true,
        unassignedPixelAssumption: 0,
        valueMode: "greyScale",
    });
    const cultureDistribution = await findDistribution(nationData, cultureData, "nation", "popdev-adjusted-culture", nationColorProperties, cultureColorProperties, {
        unassignedPixelAssumption: "Foreign",
        Adjuster: popData,
    });
    const religionDistribution = await findDistribution(nationData, religionData, "nation", "popdev-adjusted-religion", nationColorProperties, religionColorProperties, {
        unassignedPixelAssumption: "Pagan",
        Adjuster: popData,
    });
    const tradeZoneScore = await findDistribution(tradeZoneData, populationXDevelopmentData, "trade zone", "wealth", tradeZoneColorProperties, 0, {
        canIgnoreTransparentInner: true,
        valueMode: "RGBAsNum",
        unassignedPixelAssumption: 0,
    });
    addToTextOutput(`<... > Nations
     !suppress 99999

     `);
    //divide to make all constituencies make up 100(%).
    Object.keys(cultureDistribution).forEach((nationKey) => {
        let total = 0.0;
        //finding the total of all culturekey values in this nation, so we got something to divide by to find the constituencies' ratios
        Object.keys(cultureDistribution[nationKey]).forEach((CultureKey) => {
            total += cultureDistribution[nationKey][CultureKey];
        });
        //replace CultureGroups by empty, before re-initialising every culture in it from scratch
        addToTextOutput(`> ${nationKey}
       +> CultureGroups
       > CultureGroups
       `);
        //dividing and adding to autoGeneratedCffTextField
        Object.keys(cultureDistribution[nationKey]).forEach((CultureKey) => {
            addToTextOutput(`+> ${CultureKey}\n`);
            addToTextOutput(`= ${(cultureDistribution[nationKey][CultureKey] * 100) / total} ${CultureKey}.Points\n`);
        });
        addToTextOutput(`< <
       `);
    });
    //divide to make all constituencies make up 100(%).
    Object.keys(religionDistribution).forEach((nationKey) => {
        let total = 0.0;
        //finding the total of all religionkey values in this nation, so we got something to divide by to find the constituencies' ratios
        Object.keys(religionDistribution[nationKey]).forEach((ReligionKey) => {
            total += religionDistribution[nationKey][ReligionKey];
        });
        addToTextOutput(`> ${nationKey}
       +> ReligionGroups
       > ReligionGroups
       `);
        //dividing and adding to autoGeneratedCffTextField
        Object.keys(religionDistribution[nationKey]).forEach((ReligionKey) => {
            addToTextOutput(`+> ${ReligionKey}\n`);
            addToTextOutput(`= ${(religionDistribution[nationKey][ReligionKey] * 100) / total} ${ReligionKey}.Points\n`);
        });
        addToTextOutput(`< <
       `);
    });
    //add climate distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(climateDistribution).forEach((nationKey) => {
        Object.keys(climateDistribution[nationKey]).forEach((climateKey) => {
            addToTextOutput(`= ${climateDistribution[nationKey][climateKey]} ${nationKey}.${climateKey}\n`);
        });
    });
    //add development distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(developmentScore).forEach((nationKey) => {
        addToTextOutput(`= ${developmentScore[nationKey]} ${nationKey}.DevelopmentPixelCount\n`);
    });
    //add coast distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(coastPopCount).forEach((nationKey) => {
        addToTextOutput(`= ${coastPopCount[nationKey]} ${nationKey}.coastalPopulation\n`);
    });
    addToTextOutput(`<... > Nations
     `);
    /* #region  Everthing resources */
    for (let r = 0; r < mappedResources.length; r++) {
        const resourceName = mappedResources[r];
        let resourceData = null;
        resourceData = await prepareData(`Code/Resources/${resourceName}.png`);
        progressText.innerText = "";
        const resourceBlobSizes = (await findDistribution(() => {
            return 255;
        }, resourceData, "world", resourceName, [{ color: "ffffff", name: "world" }], (e) => {
            return { color: e, name: "Col" + e };
        }, {
            skipsTransparentInner: true,
            unnamedGroup: true,
        }))["world"];
        //find nations' max resources
        const resourceOverlap = await findDistribution(nationData, resourceData, "nation", resourceName, nationColorProperties, (e) => {
            return { color: e, name: "Col" + e };
        }, {
            skipsTransparentInner: true,
            unnamedGroup: true,
        });
        //use resourceBlobSizes to divide all.
        Object.keys(resourceOverlap).forEach((nationKey) => {
            let count = 0.0;
            //counting up all pixels overlapping per blob, divided by the blob's size
            Object.keys(resourceOverlap[nationKey]).forEach((ColorKey) => {
                count +=
                    resourceOverlap[nationKey][ColorKey] / resourceBlobSizes[ColorKey];
            });
            //resource blob number multiplication
            count *= mappedResourcesMultipliers[r];
            addToTextOutput(`= ${(Math.round(count * 20) / 20).toFixed(2)} ${nationKey}.Max${resourceName}
         `);
        });
    }
    /* #endregion */
    //add trade zone wealths to autogeneratedccf
    addToTextOutput(`<... > TradeZones
     `);
    //climate * totaldevscore (255 per pixel)
    Object.keys(tradeZoneScore).forEach((zoneKey) => {
        const rawTradeZoneScore = tradeZoneScore[zoneKey];
        const idealTradeZoneScore = rawTradeZoneScore / 10000;
        addToTextOutput(`= ${(Math.round(idealTradeZoneScore * 20) / 20).toFixed(2)} ${zoneKey}.Score\n`);
    });
    await prepareNewMaps();
    const URLParamSetup = new URLSearchParams(window.location.search).get("setup");
    const isSetup = URLParamSetup != null;
    console.log(isSetup);
    const nationPopDistribution = await findDistribution(nationData, isSetup ? popData : newPopData, "nation", "population", nationColorProperties, 0, {
        valueMode: "RGBAsNum",
        unassignedPixelAssumption: 0,
    });
    const nationPopXDevDistribution = await findDistribution(nationData, populationXDevelopmentData, "nation", "population", nationColorProperties, 0, {
        valueMode: "RGBAsNum",
        unassignedPixelAssumption: 0,
    });
    const nationFuturePopDistribution = await findDistribution(nationData, isSetup ? newPopData : newFuturePopData, "nation", "future population", nationColorProperties, 0, {
        valueMode: "RGBAsNum",
        unassignedPixelAssumption: 0,
    });
    const nationFertilityDistribution = await findDistribution(nationData, fertilityData, "nation", "fertility", nationColorProperties, fertilityColorProperties, {
        unassignedPixelAssumption: 0,
    });
    //add population distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(nationPopDistribution).forEach((nationKey) => {
        addToTextOutput(`= ${nationPopDistribution[nationKey]} ${nationKey}.Population\n`);
    });
    //add urban pop to autogeneratedccf
    Object.keys(nationPopXDevDistribution).forEach((nationKey) => {
        addToTextOutput(`= ${nationPopXDevDistribution[nationKey]} ${nationKey}.urbanPopulation\n`);
    });
    //add future population distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(nationFuturePopDistribution).forEach((nationKey) => {
        addToTextOutput(`= ${nationFuturePopDistribution[nationKey]} ${nationKey}.Future Population\n`);
    });
    //add fertility distributions to autogeneratedccf
    addToTextOutput(`<... > Nations
     `);
    Object.keys(nationFertilityDistribution).forEach((nationKey) => {
        let total = 0;
        Object.keys(nationFertilityDistribution[nationKey]).forEach((FertilityKey) => {
            const fertilityColor = gameStats.Fertility[FertilityKey].Color;
            let fertilityMultiplier = 0;
            fertilityColorProperties.forEach((colorNamePair) => {
                if (colorNamePair.color == fertilityColor) {
                    fertilityMultiplier = gameStats.Fertility[FertilityKey].Score;
                    return;
                }
            });
            total +=
                nationFertilityDistribution[nationKey][FertilityKey] *
                    fertilityMultiplier;
        });
        addToTextOutput(`= ${total} ${nationKey}.Fertility\n`);
    });
    addToTextOutput(`!suppress 0
      <...
      `);
    //add to autogeneratedccf
    copyToClipboardButton.disabled = false;
    progressText.innerText = `Done`;
}
function advancePopulationMap(imgArray, pixelIndex, options) {
    const gameStats = getGameStats();
    const pixel = ImageIndexToRGBA(imgArray, pixelIndex);
    if (pixel[3] < 128)
        return pixel; //if transparent, don't modify the pixel at all
    let pixelPop = pixel[0];
    pixelPop *= 255;
    pixelPop += pixel[1];
    pixelPop *= 255;
    pixelPop += pixel[2];
    const propertyData = options.propertyData;
    const colorProperties = options.colorProperties;
    const developmentData = options.development;
    function fetchPropertyObject(dataName) {
        const color = RGBAToHex(ImageIndexToRGBA(propertyData[dataName], pixelIndex));
        let pair;
        colorProperties[dataName].forEach((colorNamePair) => {
            if (colorNamePair.color == color) {
                pair = colorNamePair;
                return;
            }
        });
        return pair;
    }
    function fetchName(dataName) {
        const pair = fetchPropertyObject(dataName);
        return typeof pair !== "undefined" ? pair.name : null;
    }
    function fetchBinary(dataName, isName) {
        const propertyPair = fetchPropertyObject(dataName);
        const nullableName = propertyPair ? propertyPair.name : `not-${isName}`;
        return nullableName == isName;
    }
    const nationName = fetchName("nation");
    const n = gameStats.Nations[nationName];
    const hasVaccine = typeof n !== "undefined" ? n.Technologies.Vaccines : false;
    const pseudoPopulationGrowth = typeof n !== "undefined" ? n.PseudoPopulationGrowth : 0.1;
    const effectiveHealth = typeof n !== "undefined" ? n.EffectiveHealth : 0;
    const climateName = fetchName("climate");
    const climateScore = gameStats.Climates[climateName].ClimateScore +
        (hasVaccine
            ? climateName == "SubTropical" ||
                climateName == "Tropical" ||
                climateName == "Savanna"
                ? 0.1
                : 0
            : 0);
    const isCoastalPixel = fetchBinary("coastal", "coast");
    let developmentScore = ImageIndexToRGBA(developmentData, pixelIndex)[0]; //reading red channel as shorthand for greyscale
    developmentScore = developmentScore / 255;
    const fertilityName = fetchName("fertility");
    const fertilityScore = gameStats.Fertility[fertilityName].Score;
    const pixelsDisease = pixelPop / (20 * climateScore) / 25 -
        effectiveHealth -
        (isCoastalPixel ? 0.1 : 0) +
        (0.5 - fertilityScore) / 2.5 -
        developmentScore * 5;
    const pixelsPopGrowth = pseudoPopulationGrowth < 0
        ? pseudoPopulationGrowth
        : pseudoPopulationGrowth * (1 - pixelsDisease);
    const newPixelPop = pixelPop * (1 + pixelsPopGrowth);
    return IntColorToRGBA(newPixelPop);
}
async function prepareNewMaps() {
    const datasets = {
        nation: nationData,
        climate: climateData,
        coastal: coastData,
        fertility: fertilityData,
    };
    const colorprops = {
        nation: nationColorProperties,
        climate: climateColorProperties,
        coastal: coastColorProperties,
        fertility: fertilityColorProperties,
    };
    newPopData = await advanceMap(popData, advancePopulationMap, {
        propertyData: datasets,
        colorProperties: colorprops,
        development: developmentData,
    });
    await addToImageOutput(newPopData, "Population map");
    newFuturePopData = await advanceMap(newPopData, advancePopulationMap, {
        propertyData: datasets,
        colorProperties: colorprops,
        development: developmentData,
    });
    await addToImageOutput(newFuturePopData, "Future Population map");
    const playerReadablePopData = await advanceMap(popData, populationMapToHumanReadable, {});
    await addToImageOutput(playerReadablePopData, "Player-readable population map");
}
async function findDistribution(outerDataset, innerDataset, outerName, innerName, colorToOuterNameMapping, colorToInnerNameMapping, options) {
    const ret = {};
    let pixelCount = WIDTH * HEIGHT;
    if (options.pixelCount) {
        pixelCount = options.pixelCount;
    }
    let getOuterDataPoint;
    let getInnerDataPoint;
    if (typeof outerDataset != "function")
        getOuterDataPoint = (i) => outerDataset[i];
    else
        getOuterDataPoint = (i) => outerDataset(i);
    if (typeof innerDataset != "function")
        getInnerDataPoint = (i) => innerDataset[i];
    else
        getInnerDataPoint = (i) => innerDataset(i);
    progressText.innerText = `counting ${innerName}s in ${outerName}s`;
    let then = Date.now();
    for (let i = 0; i < pixelCount; i++) {
        const x = i % WIDTH;
        const y = Math.floor(i / WIDTH);
        //let the site know you're still alive
        const now = Date.now();
        if (now - then > 100) {
            await reportProgress(i, progressText);
            await new Promise((resolve) => setTimeout(resolve));
            then = now;
        }
        const isOuterDataEmpty = getOuterDataPoint(i * 4 + 3) == 0;
        const isInnerDataEmpty = getInnerDataPoint(i * 4 + 3) == 0;
        //if the pixel in outerDataset is transparent, skip
        if (isOuterDataEmpty)
            continue;
        //if the pixel in innerDataset is transparent, warn
        else if (isInnerDataEmpty) {
            if (options.skipsTransparentInner)
                continue;
            else if (!options.canIgnoreTransparentInner)
                console.warn(`The pixel (${x}, ${y}) is transparent in the ${innerName} image, but not the ${outerName} image. It is (${getOuterDataPoint(i * 4)}, ${getOuterDataPoint(i * 4 + 1)}, ${getOuterDataPoint(i * 4 + 2)}, ${getOuterDataPoint(i * 4 + 3)}) in the ${outerName} image. Investigate this. For now ${options.unassignedPixelAssumption} is assumed`);
        }
        const outerCol = RGBAToHex([
            getOuterDataPoint(i * 4),
            getOuterDataPoint(i * 4 + 1),
            getOuterDataPoint(i * 4 + 2),
        ]);
        const innerCol = RGBAToHex([
            getInnerDataPoint(i * 4),
            getInnerDataPoint(i * 4 + 1),
            getInnerDataPoint(i * 4 + 2),
        ]);
        let foundOuterObject = colorToOuterNameMapping.find((element) => element.color.toString().toLowerCase() ==
            outerCol.toString().toLowerCase());
        if (typeof foundOuterObject === "undefined") {
            foundOuterObject = await PromptName(outerCol, getOuterDataPoint, outerName);
            colorToOuterNameMapping.push(foundOuterObject);
        }
        const outerNameOfPixel = foundOuterObject.name;
        function adjustments() {
            if (!options.adjustForAlpha && !options.Adjuster)
                return 1;
            else if (options.Adjuster) {
                const rawMultiplier = ImageIndexToIntColor(options.Adjuster, i * 4);
                const multiplier = options.AdjusterMapping
                    ? options.AdjusterMapping(rawMultiplier)
                    : rawMultiplier;
                return multiplier;
            }
            else if (options.adjustForAlpha) {
                const alpha = getInnerDataPoint(i * 4 + 3);
                return alpha;
            }
        }
        if (options.valueMode == "greyScale") {
            const innerGreyScale = getInnerDataPoint(i * 4);
            const innerPixelValue = isInnerDataEmpty
                ? options.unassignedPixelAssumption
                : innerGreyScale;
            if (typeof ret[outerNameOfPixel] === "undefined")
                ret[outerNameOfPixel] = 0;
            const mult = adjustments();
            ret[outerNameOfPixel] += innerPixelValue * mult;
            if (isNaN(ret[outerNameOfPixel]))
                debugger;
        }
        else if (options.valueMode == "RGBAsNum") {
            const InnerPixelValue = isInnerDataEmpty
                ? options.unassignedPixelAssumption
                : ImageIndexToIntColor(innerDataset, i * 4);
            if (typeof ret[outerNameOfPixel] === "undefined")
                ret[outerNameOfPixel] = 0;
            const mult = adjustments();
            ret[outerNameOfPixel] += InnerPixelValue * mult;
        }
        else {
            let foundInnerObject = isInnerDataEmpty
                ? { color: innerCol, name: options.unassignedPixelAssumption }
                : !options.unnamedGroup
                    ? colorToInnerNameMapping.find((element) => element.color.toString().toLowerCase() ==
                        innerCol.toString().toLowerCase())
                    : { color: innerCol, name: "Col" + innerCol };
            if (typeof foundInnerObject === "undefined") {
                foundInnerObject = await PromptName(innerCol, getInnerDataPoint, innerName);
                if (!options.unnamedGroup)
                    colorToInnerNameMapping.push(foundInnerObject);
            }
            const InnerNameOfPixel = foundInnerObject.name;
            if (typeof ret[outerNameOfPixel] === "undefined")
                ret[outerNameOfPixel] = {};
            if (typeof ret[outerNameOfPixel][InnerNameOfPixel] === "undefined")
                ret[outerNameOfPixel][InnerNameOfPixel] = 0;
            const mult = adjustments();
            ret[outerNameOfPixel][InnerNameOfPixel] += 1 * mult;
        }
    }
    return ret;
}
async function PromptName(color, getDatasetPointFunction, name) {
    promptFieldReturnedText = "";
    const DatasetLength = WIDTH * HEIGHT * 4;
    const dat = new Uint8ClampedArray(DatasetLength);
    for (let j = 0; j < DatasetLength; j++) {
        dat[j] = getDatasetPointFunction(j);
    }
    for (let j = 0; j < dat.length / 4; j++) {
        if (RGBAToHex([
            getDatasetPointFunction(j * 4),
            getDatasetPointFunction(j * 4 + 1),
            getDatasetPointFunction(j * 4 + 2),
        ]) == color) {
            dat[j * 4] = getDatasetPointFunction(j * 4);
            dat[j * 4 + 1] = getDatasetPointFunction(j * 4 + 1);
            dat[j * 4 + 2] = getDatasetPointFunction(j * 4 + 2);
            dat[j * 4 + 3] = getDatasetPointFunction(j * 4 + 3);
        }
        else {
            dat[j * 4] = baseData[j * 4];
            dat[j * 4 + 1] = baseData[j * 4 + 1];
            dat[j * 4 + 2] = baseData[j * 4 + 2];
            dat[j * 4 + 3] = baseData[j * 4 + 3];
        }
    }
    const retName = await promptMap(dat, `The color #${color} did not have a matching ${name}. Which ${name} is it?\n(Give the name it has in stats)`);
    const ret = {
        color: color,
        name: retName,
    };
    addToTextOutput(`= "${color}" ${name}s.${promptFieldReturnedText}.Color\n`);
    return ret;
}
async function promptMap(imgArray, msg) {
    promptMissingInfoContainer.hidden = false;
    promptLabel.innerText = msg;
    promptedMissingInfoCanvas.getContext("2d").putImageData(new ImageData(imgArray, WIDTH), 0, 0);
    console.log("ok, just waiting now :)");
    //idle until cultureNamePrompt answered;
    let then = Date.now();
    while (promptFieldReturnedText == "") {
        const now = Date.now();
        if (now - then > 17) {
            await new Promise((resolve) => setTimeout(resolve));
            then = now;
        }
    }
    return promptFieldReturnedText;
}
async function mapDataIterator(delegate) {
    const ret = new Uint8ClampedArray(WIDTH * HEIGHT * 4);
    let then = Date.now();
    for (let i = 0; i < ret.length / 4; i++) {
        const res = delegate(i * 4);
        ret[i * 4] = res[0];
        ret[i * 4 + 1] = res[1];
        ret[i * 4 + 2] = res[2];
        ret[i * 4 + 3] = res[3];
        if (i % WIDTH == 0) {
            const now = Date.now();
            if (now - then > 100) {
                await reportProgress(i, progressText);
                await new Promise((resolve) => setTimeout(resolve));
                then = now;
            }
        }
    }
    return ret;
}
async function advanceMap(imgArray, formula, options) {
    const newImgArray = new Uint8ClampedArray(imgArray.length);
    let then = Date.now();
    for (let i = 0; i < newImgArray.length; i += 4) {
        const now = Date.now();
        if (now - then > 2000) {
            await new Promise(resolve => setTimeout(resolve));
            reportProgress(i / 4, progressText);
            then = now;
        }
        const newPixel = formula(imgArray, i, options);
        newImgArray[i] = newPixel[0];
        newImgArray[i + 1] = newPixel[1];
        newImgArray[i + 2] = newPixel[2];
        newImgArray[i + 3] = newPixel[3];
    }
    return newImgArray;
}
function addToTextOutput(text) {
    autoGeneratedCffTextField.value += trimIndents(text);
}
async function addToImageOutput(imgArray, imgName) {
    const size = 2;
    const canvasContainer = document.createElement("div");
    const canvasLabel = document.createElement("label");
    canvasLabel.innerText = imgName;
    const canvasLink = document.createElement("canvas");
    canvasLink.width = WIDTH;
    canvasLink.height = HEIGHT;
    canvasLink.style.width = size * 2 + "cm";
    canvasLink.style.height = size + "cm";
    canvasLink
        .getContext("2d")
        .putImageData(new ImageData(imgArray, WIDTH), 0, 0);
    canvasContainer.appendChild(canvasLabel);
    canvasContainer.appendChild(document.createElement("br"));
    canvasContainer.appendChild(canvasLink);
    imageOutputContainer.appendChild(canvasContainer);
}
function reverseRBGsOfDevelopment(mapIndex) {
    return [
        255 - developmentData[mapIndex],
        255 - developmentData[mapIndex + 1],
        255 - developmentData[mapIndex + 2],
        developmentData[mapIndex + 3],
    ];
}
function populationXDevelopmentMerger(mapIndex) {
    const pixelPop = ImageIndexToIntColor(popData, mapIndex);
    const pixelDev = developmentData[mapIndex] / 255;
    const ret = pixelPop * pixelDev;
    return IntColorToRGBA(ret);
}
